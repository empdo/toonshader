[gd_resource type="Shader" format=3 uid="uid://dtvjtvmtglsov"]

[resource]
code = "shader_type spatial;
render_mode unshaded;

// --- HATCH PARAMETRAR ---
uniform vec4 base_color : source_color = vec4(1.0);
uniform sampler2D albedo_tex : source_color, filter_linear_mipmap_anisotropic;
uniform bool use_albedo_tex = false;
uniform sampler2D hatch_tex : filter_nearest, repeat_enable;
uniform vec3 ink_color : source_color = vec3(0.0);
uniform float hatch_world_scale : hint_range(0.0, 10.0) = 0.1;
uniform float hatch_strength : hint_range(0.0, 4.0) = 2.0;

// --- ANTI-ALIASING FÖR HATCHING PÅ AVSTÅND ---
uniform float hatch_fade_start : hint_range(1.0, 200.0) = 10.0;
uniform float hatch_fade_end : hint_range(1.0, 400.0) = 20.0;
uniform bool use_distance_fade = true;
uniform vec3 distance_fade_color : source_color = vec3(0.15, 0.12, 0.1);

// --- DYNAMISK POSITION FÖR LJUS ---
uniform vec3 light_position_ws = vec3(0.0, 5.0, 0.0);
uniform float band1 = 0.6;
uniform float band2 = 0.4;
uniform float band3 = 0.2;
uniform float band_softness = 0.05;

varying vec3 v_world_pos;
varying vec3 v_world_nrm;

// --- HJÄLPFUNKTIONER ---
mat2 rot(float a) {
    float s = sin(a); float c = cos(a);
    return mat2(vec2(c, s), vec2(-s, c));
}

float hatch_ink(vec2 uv) {
    return 1.0 - texture(hatch_tex, uv).r;
}

float hatch_triplanar(vec3 p, vec3 n, float a) {
    n = normalize(n);
    vec3 w = pow(abs(n), vec3(4.0));
    w /= (w.x + w.y + w.z) + 1e-6;
    mat2 R = rot(a);
    float sx = hatch_ink(R * p.yz * hatch_world_scale);
    float sy = hatch_ink(R * p.xz * hatch_world_scale);
    float sz = hatch_ink(R * p.xy * hatch_world_scale);
    return sx * w.x + sy * w.y + sz * w.z;
}

void vertex() {
    v_world_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
    v_world_nrm = normalize(mat3(transpose(inverse(MODEL_MATRIX))) * NORMAL);
}

void fragment() {
    vec3 normal = normalize(v_world_nrm);

    // --- LIGHTING & HATCHING ---
    vec3 L = normalize(light_position_ws - v_world_pos);
    float NdotL = dot(normal, L);
    float light_level = max(NdotL, 0.0);

    float g1 = smoothstep(band1 + band_softness, band1 - band_softness, light_level);
    float g2 = smoothstep(band2 + band_softness, band2 - band_softness, light_level);
    float g3 = smoothstep(band3 + band_softness, band3 - band_softness, light_level);

    float h1 = hatch_triplanar(v_world_pos, normal, radians(45.0));
    float h2 = hatch_triplanar(v_world_pos, normal, radians(-45.0));
    float h3 = hatch_triplanar(v_world_pos, normal, radians(0.0));

    float combined_hatch = max(max(h1 * g1, h2 * g2), h3 * g3);
    
    // Tona ut på avstånd
    float distance_fade = 1.0;
    float fog_factor = 0.0;
    if (use_distance_fade) {
        float cam_distance = length(v_world_pos - CAMERA_POSITION_WORLD);
        distance_fade = 1.0 - smoothstep(hatch_fade_start, hatch_fade_end, cam_distance);
        fog_factor = smoothstep(hatch_fade_start, hatch_fade_end, cam_distance);
    }
    
    float ink = clamp(combined_hatch * hatch_strength * distance_fade, 0.0, 1.0);

    vec3 final_color = base_color.rgb;
    if (use_albedo_tex) final_color *= texture(albedo_tex, UV).rgb;
    final_color = mix(final_color, ink_color, ink);
    
    // Blend towards dark fog color at distance
    final_color = mix(final_color, distance_fade_color, fog_factor);

    ALBEDO = final_color;
}
"
